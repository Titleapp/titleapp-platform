// services/documentEngine/generators/pdfGenerator.js
// PDF generation via pdfkit — covers report-standard, memo-executive, one-pager

const PDFDocument = require("pdfkit");
const { MARGINS, FONTS, PAGE_SIZES, COLORS } = require("../templates/layouts");

async function generatePdf({ template, data, brand, logoBuffer }) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    const doc = new PDFDocument({
      size: "LETTER",
      margins: MARGINS.standard,
      bufferPages: true,
      info: {
        Title: data.title || "Untitled Document",
        Author: data.author || brand.name || "TitleApp",
        Creator: "TitleApp Document Engine",
        Producer: "TitleApp.ai",
      },
    });

    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    try {
      switch (template.id) {
        case "memo-executive":
          renderMemo(doc, data, brand, logoBuffer);
          break;
        case "one-pager":
          renderOnePager(doc, data, brand, logoBuffer);
          break;
        case "report-standard":
        default:
          renderReport(doc, data, brand, logoBuffer);
          break;
      }

      // Add footers to all pages
      const range = doc.bufferedPageRange();
      for (let i = range.start; i < range.start + range.count; i++) {
        doc.switchToPage(i);
        addFooter(doc, brand, i + 1, range.count);
      }

      doc.end();
    } catch (e) {
      reject(e);
    }
  });
}

// --- Shared helpers ---

function primaryColor(brand) {
  return brand.primaryColor || COLORS.primary;
}

function secondaryColor(brand) {
  return brand.secondaryColor || COLORS.secondary;
}

function contentWidth() {
  return PAGE_SIZES.letter.width - MARGINS.standard.left - MARGINS.standard.right;
}

function addHeader(doc, brand, logoBuffer) {
  const startY = MARGINS.standard.top;
  if (logoBuffer) {
    try {
      doc.image(logoBuffer, MARGINS.standard.left, startY - 10, { height: 32 });
    } catch (e) {
      // Logo failed to load — skip silently
    }
  }
  const lineY = startY + 30;
  doc.moveTo(MARGINS.standard.left, lineY)
    .lineTo(PAGE_SIZES.letter.width - MARGINS.standard.right, lineY)
    .strokeColor(primaryColor(brand))
    .lineWidth(2)
    .stroke();
  doc.y = lineY + 12;
}

function addFooter(doc, brand, pageNum, totalPages) {
  const y = PAGE_SIZES.letter.height - MARGINS.standard.bottom + 10;
  const w = contentWidth();

  // Separator line
  doc.save();
  doc.moveTo(MARGINS.standard.left, y - 8)
    .lineTo(PAGE_SIZES.letter.width - MARGINS.standard.right, y - 8)
    .strokeColor(COLORS.border)
    .lineWidth(0.5)
    .stroke();

  // AI disclosure (P0.9) — lineBreak: false prevents PDFKit from creating new pages
  doc.fontSize(FONTS.footer.size)
    .font(FONTS.footer.font)
    .fillColor(COLORS.textLight)
    .text(
      brand.aiDisclosure ||
        "Generated by TitleApp Digital Worker. AI-assisted analysis — human review recommended.",
      MARGINS.standard.left,
      y,
      { width: w - 60, align: "left", lineBreak: false }
    );

  // Page number — lineBreak: false to stay on current page
  doc.text(
    `${pageNum} / ${totalPages}`,
    MARGINS.standard.left,
    y,
    { width: w, align: "right", lineBreak: false }
  );
  doc.restore();
}

// --- Report layout ---

function renderReport(doc, data, brand, logoBuffer) {
  // Cover page
  addHeader(doc, brand, logoBuffer);
  doc.moveDown(3);
  doc.fontSize(26)
    .font("Helvetica-Bold")
    .fillColor(primaryColor(brand))
    .text(data.title, { align: "center" });

  if (data.subtitle) {
    doc.moveDown(0.5);
    doc.fontSize(FONTS.subheading.size)
      .font("Helvetica")
      .fillColor(secondaryColor(brand))
      .text(data.subtitle, { align: "center" });
  }

  doc.moveDown(3);
  doc.fontSize(FONTS.body.size)
    .font(FONTS.body.font)
    .fillColor(COLORS.text);

  if (data.author) {
    doc.text(`Prepared by: ${data.author}`, { align: "center" });
  }
  doc.text(
    `Date: ${data.date || new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}`,
    { align: "center" }
  );

  if (data.preparedFor) {
    doc.text(`Prepared for: ${data.preparedFor}`, { align: "center" });
  }

  // Confidentiality notice
  doc.moveDown(4);
  doc.fontSize(FONTS.caption.size)
    .font(FONTS.caption.font)
    .fillColor(COLORS.textLight)
    .text(
      brand.footerText || "Confidential — Generated by TitleApp.ai",
      { align: "center" }
    );

  // Body sections
  const sections = data.sections || [];
  for (const section of sections) {
    doc.addPage();
    addHeader(doc, brand, logoBuffer);

    doc.fontSize(FONTS.heading.size)
      .font(FONTS.heading.font)
      .fillColor(primaryColor(brand))
      .text(section.title || "Section");

    doc.moveDown(0.5);

    // Section highlights (key-value pairs)
    if (section.highlights && Array.isArray(section.highlights)) {
      for (const h of section.highlights) {
        doc.fontSize(FONTS.label.size)
          .font(FONTS.label.font)
          .fillColor(COLORS.textLight)
          .text(h.label + ": ", { continued: true });
        doc.font(FONTS.body.font)
          .fillColor(COLORS.text)
          .text(h.value || "");
      }
      doc.moveDown(0.5);
    }

    // Section body text
    doc.fontSize(FONTS.body.size)
      .font(FONTS.body.font)
      .fillColor(COLORS.text);

    if (typeof section.content === "string") {
      doc.text(section.content, { lineGap: 4 });
    } else if (Array.isArray(section.content)) {
      for (const para of section.content) {
        if (typeof para === "string") {
          doc.text(para, { lineGap: 4 });
          doc.moveDown(0.5);
        }
      }
    }

    // Section table
    if (section.table && Array.isArray(section.table.rows)) {
      doc.moveDown(0.5);
      renderSimpleTable(doc, section.table, brand);
    }
  }

  // Appendix
  if (data.appendix) {
    doc.addPage();
    addHeader(doc, brand, logoBuffer);
    doc.fontSize(FONTS.heading.size)
      .font(FONTS.heading.font)
      .fillColor(primaryColor(brand))
      .text("Appendix");
    doc.moveDown(0.5);
    doc.fontSize(FONTS.body.size)
      .font(FONTS.body.font)
      .fillColor(COLORS.text);
    if (typeof data.appendix === "string") {
      doc.text(data.appendix, { lineGap: 4 });
    } else if (Array.isArray(data.appendix)) {
      for (const item of data.appendix) {
        doc.text(typeof item === "string" ? item : JSON.stringify(item), { lineGap: 4 });
        doc.moveDown(0.3);
      }
    }
  }
}

// --- Memo layout ---

function renderMemo(doc, data, brand, logoBuffer) {
  addHeader(doc, brand, logoBuffer);

  doc.fontSize(FONTS.heading.size)
    .font(FONTS.heading.font)
    .fillColor(primaryColor(brand))
    .text("MEMORANDUM");
  doc.moveDown(0.8);

  // Header fields
  const fields = [
    { label: "TO", value: data.to },
    { label: "FROM", value: data.from },
    { label: "DATE", value: data.date || new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" }) },
    { label: "RE", value: data.subject || data.title },
  ];
  if (data.cc) {
    fields.push({ label: "CC", value: data.cc });
  }

  for (const f of fields) {
    doc.fontSize(FONTS.body.size);
    doc.font(FONTS.label.font)
      .fillColor(COLORS.textLight)
      .text(`${f.label}:`, MARGINS.standard.left, doc.y, { continued: true, width: 50 });
    doc.font(FONTS.body.font)
      .fillColor(COLORS.text)
      .text(`  ${f.value || ""}`, { lineGap: 2 });
  }

  // Divider
  doc.moveDown(0.5);
  doc.moveTo(MARGINS.standard.left, doc.y)
    .lineTo(PAGE_SIZES.letter.width - MARGINS.standard.right, doc.y)
    .strokeColor(COLORS.border)
    .lineWidth(1)
    .stroke();
  doc.moveDown(1);

  // Body
  doc.fontSize(FONTS.body.size)
    .font(FONTS.body.font)
    .fillColor(COLORS.text);

  if (typeof data.body === "string") {
    doc.text(data.body, { lineGap: 4 });
  } else if (Array.isArray(data.body)) {
    for (const para of data.body) {
      doc.text(para, { lineGap: 4 });
      doc.moveDown(0.5);
    }
  }

  // Recommendation
  if (data.recommendation) {
    doc.moveDown(1);
    doc.fontSize(FONTS.subheading.size)
      .font(FONTS.subheading.font)
      .fillColor(primaryColor(brand))
      .text("Recommendation");
    doc.moveDown(0.3);
    doc.fontSize(FONTS.body.size)
      .font(FONTS.body.font)
      .fillColor(COLORS.text)
      .text(data.recommendation, { lineGap: 4 });
  }
}

// --- One-pager layout ---

function renderOnePager(doc, data, brand, logoBuffer) {
  addHeader(doc, brand, logoBuffer);

  doc.fontSize(22)
    .font("Helvetica-Bold")
    .fillColor(primaryColor(brand))
    .text(data.title, { align: "center" });

  if (data.subtitle) {
    doc.moveDown(0.2);
    doc.fontSize(FONTS.body.size)
      .font(FONTS.body.font)
      .fillColor(COLORS.textLight)
      .text(data.subtitle, { align: "center" });
  }

  doc.moveDown(1);

  // Metrics grid
  if (data.metrics && Array.isArray(data.metrics)) {
    const metricsPerRow = Math.min(data.metrics.length, 3);
    const colWidth = contentWidth() / metricsPerRow;

    for (let i = 0; i < data.metrics.length; i++) {
      const m = data.metrics[i];
      const col = i % metricsPerRow;
      const x = MARGINS.standard.left + col * colWidth;

      if (col === 0 && i > 0) {
        doc.moveDown(1.5);
      }

      const rowY = doc.y;

      doc.fontSize(FONTS.metric.size)
        .font(FONTS.metric.font)
        .fillColor(primaryColor(brand))
        .text(String(m.value || "0"), x, rowY, {
          width: colWidth,
          align: "center",
        });

      doc.fontSize(FONTS.caption.size)
        .font(FONTS.caption.font)
        .fillColor(COLORS.textLight)
        .text(m.label || "", x, rowY + 28, {
          width: colWidth,
          align: "center",
        });

      // Reset Y for same row
      if (col < metricsPerRow - 1 && i < data.metrics.length - 1) {
        doc.y = rowY;
      }
    }

    doc.moveDown(2);
  }

  // Highlights
  if (data.highlights && Array.isArray(data.highlights)) {
    doc.fontSize(FONTS.subheading.size)
      .font(FONTS.subheading.font)
      .fillColor(primaryColor(brand))
      .text("Key Highlights");
    doc.moveDown(0.3);

    doc.fontSize(FONTS.body.size)
      .font(FONTS.body.font)
      .fillColor(COLORS.text);

    for (const h of data.highlights) {
      const text = typeof h === "string" ? h : h.text || h.label || "";
      doc.text(`  \u2022  ${text}`, { lineGap: 3 });
    }
  }

  // Call to action
  if (data.callToAction) {
    doc.moveDown(1);
    doc.fontSize(FONTS.body.size)
      .font("Helvetica-Bold")
      .fillColor(primaryColor(brand))
      .text(data.callToAction, { align: "center" });
  }

  // Contact info
  if (data.contactInfo) {
    doc.moveDown(0.5);
    doc.fontSize(FONTS.caption.size)
      .font(FONTS.caption.font)
      .fillColor(COLORS.textLight)
      .text(data.contactInfo, { align: "center" });
  }
}

// --- Simple table renderer ---

function renderSimpleTable(doc, table, brand) {
  const headers = table.headers || [];
  const rows = table.rows || [];
  if (headers.length === 0 && rows.length === 0) return;

  const w = contentWidth();
  const colCount = headers.length || (rows[0] && rows[0].length) || 1;
  const colWidth = w / colCount;
  const startX = MARGINS.standard.left;
  let y = doc.y;

  // Header row
  if (headers.length > 0) {
    doc.fontSize(FONTS.label.size)
      .font(FONTS.label.font)
      .fillColor(COLORS.white);

    // Header background
    doc.rect(startX, y, w, 20)
      .fill(primaryColor(brand));

    for (let i = 0; i < headers.length; i++) {
      doc.fillColor(COLORS.white)
        .text(String(headers[i]), startX + i * colWidth + 4, y + 5, {
          width: colWidth - 8,
          align: "left",
        });
    }
    y += 22;
  }

  // Data rows
  doc.fontSize(FONTS.body.size)
    .font(FONTS.body.font)
    .fillColor(COLORS.text);

  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];

    // Alternating row background
    if (r % 2 === 0) {
      doc.rect(startX, y, w, 18)
        .fill(COLORS.background);
    }

    doc.fillColor(COLORS.text);
    const cells = Array.isArray(row) ? row : Object.values(row);
    for (let i = 0; i < cells.length && i < colCount; i++) {
      doc.text(String(cells[i] || ""), startX + i * colWidth + 4, y + 4, {
        width: colWidth - 8,
        align: "left",
      });
    }
    y += 20;

    // Page break if needed
    if (y > PAGE_SIZES.letter.height - MARGINS.standard.bottom - 40) {
      doc.addPage();
      y = MARGINS.standard.top;
    }
  }

  doc.y = y + 8;
}

module.exports = { generatePdf };
