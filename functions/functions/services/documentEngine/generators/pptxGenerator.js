// services/documentEngine/generators/pptxGenerator.js
// PPTX generation via pptxgenjs — covers deck-standard

const PptxGenJS = require("pptxgenjs");
const { COLORS } = require("../templates/layouts");

async function generatePptx({ template, data, brand, logoBuffer }) {
  const pptx = new PptxGenJS();

  pptx.author = "TitleApp Document Engine";
  pptx.company = brand.name || "TitleApp";
  pptx.title = data.title || "Untitled Presentation";
  pptx.subject = data.subtitle || "";
  pptx.layout = "LAYOUT_WIDE";

  const primary = brand.primaryColor || COLORS.primary;
  const secondary = brand.secondaryColor || COLORS.secondary;
  const disclosure =
    brand.aiDisclosure ||
    "Generated by a TitleApp Digital Worker. AI-assisted — human review recommended.";

  // Title slide
  const titleSlide = pptx.addSlide();
  titleSlide.background = { color: secondary.replace("#", "") };

  // Logo on title slide
  if (logoBuffer) {
    try {
      const base64 = logoBuffer.toString("base64");
      const ext = detectImageType(logoBuffer);
      titleSlide.addImage({
        data: `image/${ext};base64,${base64}`,
        x: 0.5,
        y: 0.4,
        h: 0.8,
        sizing: { type: "contain", h: 0.8 },
      });
    } catch (e) {
      // Logo failed — skip
    }
  }

  titleSlide.addText(data.title || "Untitled", {
    x: 0.5,
    y: 2.0,
    w: "90%",
    fontSize: 36,
    bold: true,
    color: "FFFFFF",
    fontFace: "Arial",
  });

  if (data.subtitle) {
    titleSlide.addText(data.subtitle, {
      x: 0.5,
      y: 3.0,
      w: "90%",
      fontSize: 20,
      color: primary.replace("#", ""),
      fontFace: "Arial",
    });
  }

  const metaLine = [
    data.presenter,
    data.date ||
      new Date().toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      }),
  ]
    .filter(Boolean)
    .join("  |  ");

  if (metaLine) {
    titleSlide.addText(metaLine, {
      x: 0.5,
      y: 4.2,
      w: "90%",
      fontSize: 14,
      color: "A0A0A0",
      fontFace: "Arial",
    });
  }

  // AI disclosure on title slide
  titleSlide.addText(disclosure, {
    x: 0.3,
    y: 6.8,
    w: "95%",
    fontSize: 8,
    color: "808080",
    fontFace: "Arial",
    italic: true,
  });

  // Content slides
  const slides = data.slides || [];
  for (const slideData of slides) {
    const slide = pptx.addSlide();

    // Top accent bar
    slide.addShape(pptx.shapes.RECTANGLE, {
      x: 0,
      y: 0,
      w: "100%",
      h: 0.06,
      fill: { color: primary.replace("#", "") },
    });

    // Slide title
    slide.addText(slideData.title || "", {
      x: 0.5,
      y: 0.3,
      w: "90%",
      fontSize: 28,
      bold: true,
      color: secondary.replace("#", ""),
      fontFace: "Arial",
    });

    let contentY = 1.2;

    // Subtitle
    if (slideData.subtitle) {
      slide.addText(slideData.subtitle, {
        x: 0.5,
        y: contentY,
        w: "90%",
        fontSize: 16,
        color: "6B7280",
        fontFace: "Arial",
      });
      contentY += 0.6;
    }

    // Bullet points
    if (slideData.bullets && Array.isArray(slideData.bullets)) {
      const bulletTexts = slideData.bullets.map((b) => ({
        text: typeof b === "string" ? b : b.text || "",
        options: {
          fontSize: 16,
          color: "333333",
          fontFace: "Arial",
          bullet: { type: "bullet" },
          paraSpaceAfter: 8,
        },
      }));

      slide.addText(bulletTexts, {
        x: 0.7,
        y: contentY,
        w: "85%",
        h: 4.5,
        valign: "top",
      });
    }

    // Body text (alternative to bullets)
    if (slideData.body && !slideData.bullets) {
      slide.addText(slideData.body, {
        x: 0.5,
        y: contentY,
        w: "90%",
        h: 4.5,
        fontSize: 16,
        color: "333333",
        fontFace: "Arial",
        valign: "top",
      });
    }

    // Key metrics row
    if (slideData.metrics && Array.isArray(slideData.metrics)) {
      const metricsY = 5.0;
      const count = Math.min(slideData.metrics.length, 4);
      const colW = 12 / count;

      for (let i = 0; i < count; i++) {
        const m = slideData.metrics[i];
        const x = 0.5 + i * colW;

        slide.addText(String(m.value || "0"), {
          x,
          y: metricsY,
          w: colW - 0.3,
          fontSize: 28,
          bold: true,
          color: primary.replace("#", ""),
          fontFace: "Arial",
          align: "center",
        });

        slide.addText(m.label || "", {
          x,
          y: metricsY + 0.6,
          w: colW - 0.3,
          fontSize: 11,
          color: "6B7280",
          fontFace: "Arial",
          align: "center",
        });
      }
    }

    // Notes (speaker notes)
    if (slideData.notes) {
      slide.addNotes(slideData.notes);
    }

    // Footer with disclosure
    slide.addText(disclosure, {
      x: 0.3,
      y: 6.8,
      w: "95%",
      fontSize: 8,
      color: "808080",
      fontFace: "Arial",
      italic: true,
    });
  }

  // Closing slide
  const closingSlide = pptx.addSlide();
  closingSlide.background = { color: secondary.replace("#", "") };

  closingSlide.addText(data.closingTitle || "Thank You", {
    x: 0.5,
    y: 2.5,
    w: "90%",
    fontSize: 36,
    bold: true,
    color: "FFFFFF",
    fontFace: "Arial",
    align: "center",
  });

  if (data.closingSubtitle || data.contactInfo) {
    closingSlide.addText(data.closingSubtitle || data.contactInfo || "", {
      x: 0.5,
      y: 3.5,
      w: "90%",
      fontSize: 18,
      color: primary.replace("#", ""),
      fontFace: "Arial",
      align: "center",
    });
  }

  closingSlide.addText(disclosure, {
    x: 0.3,
    y: 6.8,
    w: "95%",
    fontSize: 8,
    color: "808080",
    fontFace: "Arial",
    italic: true,
  });

  // Generate buffer
  const uint8 = await pptx.write({ outputType: "nodebuffer" });
  return Buffer.from(uint8);
}

function detectImageType(buffer) {
  if (!buffer || buffer.length < 4) return "png";
  // PNG: 89 50 4E 47
  if (buffer[0] === 0x89 && buffer[1] === 0x50) return "png";
  // JPEG: FF D8 FF
  if (buffer[0] === 0xff && buffer[1] === 0xd8) return "jpeg";
  return "png";
}

module.exports = { generatePptx };
