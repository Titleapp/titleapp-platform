// services/documentEngine/generators/xlsxGenerator.js
// XLSX generation via exceljs — covers model-cashflow, model-proforma

const ExcelJS = require("exceljs");
const { COLORS } = require("../templates/layouts");

async function generateXlsx({ template, data, brand }) {
  const workbook = new ExcelJS.Workbook();
  workbook.creator = "TitleApp Document Engine";
  workbook.created = new Date();
  workbook.properties.date1904 = false;

  switch (template.id) {
    case "model-proforma":
      buildProforma(workbook, data, brand);
      break;
    case "model-cashflow":
    default:
      buildCashflow(workbook, data, brand);
      break;
  }

  return workbook.xlsx.writeBuffer();
}

function headerFill(brand) {
  const color = (brand.primaryColor || COLORS.primary).replace("#", "");
  return {
    type: "pattern",
    pattern: "solid",
    fgColor: { argb: `FF${color}` },
  };
}

function headerFont() {
  return { bold: true, color: { argb: "FFFFFFFF" }, size: 11, name: "Arial" };
}

function currencyFormat() {
  return '"$"#,##0.00';
}

function percentFormat() {
  return "0.00%";
}

function numberFormat() {
  return "#,##0";
}

function styleHeaderRow(row, brand) {
  row.eachCell((cell) => {
    cell.fill = headerFill(brand);
    cell.font = headerFont();
    cell.alignment = { horizontal: "center", vertical: "middle" };
    cell.border = {
      bottom: { style: "thin", color: { argb: "FFE5E7EB" } },
    };
  });
  row.height = 24;
}

function addDisclosureRow(sheet, brand, colCount) {
  sheet.addRow([]);
  const discRow = sheet.addRow([
    brand.aiDisclosure ||
      "Generated by a TitleApp Digital Worker. AI-assisted analysis — human review recommended.",
  ]);
  discRow.getCell(1).font = {
    italic: true,
    size: 9,
    color: { argb: "FF6B7280" },
    name: "Arial",
  };
  sheet.mergeCells(discRow.number, 1, discRow.number, colCount);
}

// --- Cash Flow Model ---

function buildCashflow(workbook, data, brand) {
  const title = data.title || "Cash Flow Model";
  const periods = data.periods || [];

  // Summary sheet
  const summary = workbook.addWorksheet("Summary");
  summary.getColumn(1).width = 28;
  summary.addRow([title]).font = {
    bold: true,
    size: 14,
    color: { argb: `FF${(brand.primaryColor || COLORS.primary).replace("#", "")}` },
    name: "Arial",
  };
  summary.addRow([`Generated: ${new Date().toLocaleDateString("en-US")}`]).font = {
    size: 10,
    color: { argb: "FF6B7280" },
    name: "Arial",
  };
  summary.addRow([]);

  // Assumptions sheet
  if (data.assumptions && Array.isArray(data.assumptions)) {
    const assumptions = workbook.addWorksheet("Assumptions");
    assumptions.columns = [
      { header: "Assumption", key: "name", width: 30 },
      { header: "Value", key: "value", width: 20 },
      { header: "Notes", key: "notes", width: 40 },
    ];
    styleHeaderRow(assumptions.getRow(1), brand);

    for (const a of data.assumptions) {
      assumptions.addRow({
        name: a.name || a.label || "",
        value: a.value || "",
        notes: a.notes || "",
      });
    }

    addDisclosureRow(assumptions, brand, 3);
  }

  // Revenue sheet
  if (data.revenue && Array.isArray(data.revenue)) {
    const revenue = workbook.addWorksheet("Revenue");
    const headers = ["Line Item", ...periods.map((p) => p.label || p)];
    revenue.addRow(headers);
    styleHeaderRow(revenue.getRow(1), brand);

    revenue.getColumn(1).width = 28;
    for (let i = 2; i <= headers.length; i++) {
      revenue.getColumn(i).width = 16;
      revenue.getColumn(i).numFmt = currencyFormat();
    }

    for (const item of data.revenue) {
      const row = [item.name || item.label || ""];
      const values = item.values || item.amounts || [];
      for (const v of values) {
        row.push(typeof v === "number" ? v : parseFloat(v) || 0);
      }
      revenue.addRow(row);
    }

    addDisclosureRow(revenue, brand, headers.length);
  }

  // Expenses sheet
  if (data.expenses && Array.isArray(data.expenses)) {
    const expenses = workbook.addWorksheet("Expenses");
    const headers = ["Line Item", ...periods.map((p) => p.label || p)];
    expenses.addRow(headers);
    styleHeaderRow(expenses.getRow(1), brand);

    expenses.getColumn(1).width = 28;
    for (let i = 2; i <= headers.length; i++) {
      expenses.getColumn(i).width = 16;
      expenses.getColumn(i).numFmt = currencyFormat();
    }

    for (const item of data.expenses) {
      const row = [item.name || item.label || ""];
      const values = item.values || item.amounts || [];
      for (const v of values) {
        row.push(typeof v === "number" ? v : parseFloat(v) || 0);
      }
      expenses.addRow(row);
    }

    addDisclosureRow(expenses, brand, headers.length);
  }

  // Cash Flow sheet
  const cf = workbook.addWorksheet("Cash Flow");
  const cfHeaders = ["Line Item", ...periods.map((p) => p.label || p)];
  cf.addRow(cfHeaders);
  styleHeaderRow(cf.getRow(1), brand);

  cf.getColumn(1).width = 28;
  for (let i = 2; i <= cfHeaders.length; i++) {
    cf.getColumn(i).width = 16;
    cf.getColumn(i).numFmt = currencyFormat();
  }

  // Auto-calculate net cash flow if revenue and expenses provided
  if (data.revenue && data.expenses) {
    const totalRevByPeriod = new Array(periods.length).fill(0);
    const totalExpByPeriod = new Array(periods.length).fill(0);

    for (const item of data.revenue || []) {
      const vals = item.values || item.amounts || [];
      for (let i = 0; i < vals.length; i++) {
        totalRevByPeriod[i] += typeof vals[i] === "number" ? vals[i] : parseFloat(vals[i]) || 0;
      }
    }
    for (const item of data.expenses || []) {
      const vals = item.values || item.amounts || [];
      for (let i = 0; i < vals.length; i++) {
        totalExpByPeriod[i] += typeof vals[i] === "number" ? vals[i] : parseFloat(vals[i]) || 0;
      }
    }

    cf.addRow(["Total Revenue", ...totalRevByPeriod]).font = { bold: true, name: "Arial" };
    cf.addRow(["Total Expenses", ...totalExpByPeriod]).font = { bold: true, name: "Arial" };

    const netCf = totalRevByPeriod.map((r, i) => r - totalExpByPeriod[i]);
    const netRow = cf.addRow(["Net Cash Flow", ...netCf]);
    netRow.font = { bold: true, name: "Arial" };
    netRow.eachCell((cell, colNum) => {
      if (colNum > 1) {
        const val = typeof cell.value === "number" ? cell.value : 0;
        cell.font = {
          bold: true,
          color: { argb: val >= 0 ? "FF16A34A" : "FFDC2626" },
          name: "Arial",
        };
      }
    });
  }

  // Custom cash flow rows
  if (data.cashflow && Array.isArray(data.cashflow)) {
    for (const item of data.cashflow) {
      const row = [item.name || item.label || ""];
      const values = item.values || item.amounts || [];
      for (const v of values) {
        row.push(typeof v === "number" ? v : parseFloat(v) || 0);
      }
      cf.addRow(row);
    }
  }

  addDisclosureRow(cf, brand, cfHeaders.length);

  // Summary metrics
  if (data.notes) {
    summary.addRow(["Notes"]).font = { bold: true, name: "Arial" };
    const notesText = Array.isArray(data.notes) ? data.notes.join("\n") : data.notes;
    summary.addRow([notesText]);
  }

  addDisclosureRow(summary, brand, 1);
}

// --- Pro Forma Model ---

function buildProforma(workbook, data, brand) {
  const title = data.title || "Pro Forma Analysis";
  const propData = data.propertyData || {};

  // Summary sheet
  const summary = workbook.addWorksheet("Summary");
  summary.getColumn(1).width = 30;
  summary.getColumn(2).width = 20;
  summary.addRow([title]).font = {
    bold: true,
    size: 14,
    color: { argb: `FF${(brand.primaryColor || COLORS.primary).replace("#", "")}` },
    name: "Arial",
  };
  summary.addRow([`Generated: ${new Date().toLocaleDateString("en-US")}`]).font = {
    size: 10,
    color: { argb: "FF6B7280" },
    name: "Arial",
  };
  summary.addRow([]);

  // Property overview
  const overviewFields = [
    ["Property Name", propData.name || propData.address || ""],
    ["Property Type", propData.type || ""],
    ["Units / SF", propData.units || propData.sqft || ""],
    ["Year Built", propData.yearBuilt || ""],
    ["Location", propData.location || propData.market || ""],
  ];
  for (const [label, value] of overviewFields) {
    if (value) {
      const row = summary.addRow([label, value]);
      row.getCell(1).font = { bold: true, name: "Arial" };
    }
  }

  // Acquisition sheet
  const acq = workbook.addWorksheet("Acquisition");
  acq.columns = [
    { header: "Item", key: "item", width: 30 },
    { header: "Amount", key: "amount", width: 20 },
    { header: "Per Unit", key: "perUnit", width: 16 },
    { header: "Notes", key: "notes", width: 30 },
  ];
  styleHeaderRow(acq.getRow(1), brand);
  acq.getColumn(2).numFmt = currencyFormat();
  acq.getColumn(3).numFmt = currencyFormat();

  const acqItems = propData.acquisition || data.acquisition || [];
  for (const item of acqItems) {
    acq.addRow({
      item: item.name || item.label || "",
      amount: item.amount || item.value || 0,
      perUnit: item.perUnit || "",
      notes: item.notes || "",
    });
  }

  addDisclosureRow(acq, brand, 4);

  // Operating sheet
  const ops = workbook.addWorksheet("Operating");
  const periods = data.periods || propData.periods || ["Year 1", "Year 2", "Year 3", "Year 4", "Year 5"];
  const opsHeaders = ["Line Item", ...periods.map((p) => p.label || p)];
  ops.addRow(opsHeaders);
  styleHeaderRow(ops.getRow(1), brand);
  ops.getColumn(1).width = 28;
  for (let i = 2; i <= opsHeaders.length; i++) {
    ops.getColumn(i).width = 16;
    ops.getColumn(i).numFmt = currencyFormat();
  }

  const opsItems = propData.operating || data.operating || [];
  for (const item of opsItems) {
    const row = [item.name || item.label || ""];
    const values = item.values || item.amounts || [];
    for (const v of values) {
      row.push(typeof v === "number" ? v : parseFloat(v) || 0);
    }
    const addedRow = ops.addRow(row);
    if (item.bold || item.total) {
      addedRow.font = { bold: true, name: "Arial" };
    }
  }

  addDisclosureRow(ops, brand, opsHeaders.length);

  // Returns sheet
  const returns = workbook.addWorksheet("Returns");
  returns.columns = [
    { header: "Metric", key: "metric", width: 28 },
    { header: "Value", key: "value", width: 20 },
  ];
  styleHeaderRow(returns.getRow(1), brand);

  const returnMetrics = propData.returns || data.returns || [];
  for (const m of returnMetrics) {
    const row = returns.addRow({
      metric: m.name || m.label || m.metric || "",
      value: m.value || "",
    });
    if (m.highlight) {
      row.getCell(2).font = {
        bold: true,
        color: { argb: `FF${(brand.primaryColor || COLORS.primary).replace("#", "")}` },
        name: "Arial",
      };
    }
  }

  addDisclosureRow(returns, brand, 2);

  // Assumptions
  if (data.assumptions && Array.isArray(data.assumptions)) {
    const assumptions = workbook.addWorksheet("Assumptions");
    assumptions.columns = [
      { header: "Assumption", key: "name", width: 30 },
      { header: "Value", key: "value", width: 20 },
      { header: "Notes", key: "notes", width: 40 },
    ];
    styleHeaderRow(assumptions.getRow(1), brand);

    for (const a of data.assumptions) {
      assumptions.addRow({
        name: a.name || a.label || "",
        value: a.value || "",
        notes: a.notes || "",
      });
    }

    addDisclosureRow(assumptions, brand, 3);
  }

  addDisclosureRow(summary, brand, 2);
}

module.exports = { generateXlsx };
